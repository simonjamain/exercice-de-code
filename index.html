<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Résultats du 1er tour des élections présidentielles 2022 à Poitiers</title>
		<style>
			.resultsGraph {
				width: 500px;
				height: 300px;
			}
		</style>
	</head>
	<body>
		<canvas id="shapesCanvas" class="resultsGraph"></canvas>
		<ul class="resultsList"></ul>
	</body>
	<script>
		// paramètres
		const APIEndpointUrl = "https://data.grandpoitiers.fr/api/v2/catalog/datasets/resultats_election_fichier_eirel_definitif/records"
		const nbVoteColumnPrefix = "nb_voix_"
		const candidateNameColumnPrefix = "candidat_"
		const totalVotesColumn = "totalVotes"
		const numberOfCandidates = 12

		async function fillResultCanvasFromOpenData() {
			
			// 1 on récupère les résultats des candidats
			const candidatesResultsRaw = await getCandidatesResultsFromAPI(APIEndpointUrl)

			// 2 on met en forme le tableau reçu pour qu'il soit exploitable
			const candidatesResults = []
			const totalVotes = candidatesResultsRaw["totalVotes"]
			for (let candidateNumber = 1; candidateNumber <= numberOfCandidates; candidateNumber++) {
				const currentCandidateVotes = candidatesResultsRaw[nbVoteColumnPrefix + candidateNumber]
				const proportionOfVotes = currentCandidateVotes / totalVotes
				candidatesResults.push(
					{
						"name" : candidatesResultsRaw[candidateNameColumnPrefix + candidateNumber],
						"nbVotes" : currentCandidateVotes,
						"proportionOfVotes" : proportionOfVotes,
						"color" : generateCandidateColor(candidateNumber)
					}
				)
			}
			// Note: on peut maintenant contrôler la concordance des scores avec la publication officielle de Poitiers : https://www.poitiers.fr/actualites/resultats-du-1er-tour-de-lelection-presidentielle-dans-la-ville-de-poitiers 

			// 2 on affiche les résultats sur le canvas
			const resultsCanvas = document.getElementById('shapesCanvas');
			const resultsCanvasCtx = resultsCanvas.getContext('2d');

			let nextStartXPosition = 0
			candidatesResults.forEach(candidatesResult => {
				const x = nextStartXPosition
				const y = 0
				const width = candidatesResult.proportionOfVotes * resultsCanvas.width
				const height = resultsCanvas.height
				resultsCanvasCtx.fillStyle = candidatesResult.color
				// on arrondi pour avoir une séparation nette
				resultsCanvasCtx.fillRect(Math.round(x), y, Math.round(width), height)
				nextStartXPosition += width
			});
			

			// 3 on trie le tableau de résultats

			// 4 on affiche la liste des résultats à côté
						

			async function getCandidatesResultsFromAPI(endpointUrl) {
				// on va récupérer directement la somme des voix pour chaque candidat ainsi que le nom de chaque candidats et le total des voix
				// grâce au langage ODSQL proposé par opendatasoft : https://help.opendatasoft.com/apis/ods-explore-v2/#section/Opendatasoft-Query-Language-(ODSQL)
				// on va pouvoir faire sum(nb_voix_n), candidat_n group_by candidat_n avec tous les candidats
				// et également récupérer le total des voix avec sum(nb_voix_n) + sum(nb_voix_n+1)...
				const candidatesNamesRawQueryStrings = []
				const candidatesVotesRawQueryStrings = []
				const totalVotesRawQueryStrings = []
				for (let candidateNumber = 1; candidateNumber <= numberOfCandidates; candidateNumber++) {
					candidatesVotesRawQueryStrings.push(`sum(nb_voix_${candidateNumber}) as nb_voix_${candidateNumber}`)
					candidatesNamesRawQueryStrings.push(`candidat_${candidateNumber}`)
					totalVotesRawQueryStrings.push(`sum(nb_voix_${candidateNumber})`)
				}
				// construction du select avec les noms, nombre de voix et total des voix
				const candidatesNamesRawQueryString = candidatesNamesRawQueryStrings.join(',')
				const candidatesVotesRawQueryString = candidatesVotesRawQueryStrings.join(',')
				const totalVotesRawQueryString = `${totalVotesRawQueryStrings.join('+')} as ${totalVotesColumn}`
				const selectQueryString = encodeURIComponent(`${candidatesNamesRawQueryString},${candidatesVotesRawQueryString},${totalVotesRawQueryString}`)

				// construction du group by avec les noms des candidats
				const groupByRawQueryString = candidatesNamesRawQueryStrings.join(',')
				const groupByQueryString = encodeURIComponent(groupByRawQueryString)

				const urlCall = `${endpointUrl}?select=${selectQueryString}&group_by=${groupByQueryString}`
				console.log(urlCall)
				
				const electionResultsResponse = await fetch(urlCall)
				const electionResults = await electionResultsResponse.json()

				//return the first and only row
				return electionResults.records[0].record.fields
			}

			function generateCandidateColor(candidateNumber) {
				// pour l'instant nous n'utilisons pas l'information du numéro du candidat
				const randomHexValue = Math.floor(Math.random()*0xffffff)
				const randomHexValueWithLeadingZerosStr = ("000000" + randomHexValue.toString(16)).substr(-6)
				return `#${randomHexValueWithLeadingZerosStr}`
			}
		}
		fillResultCanvasFromOpenData()

	</script>
</html>
